{"id":592440987,"lang":"cpp","lang_name":"C++","time":"1 year, 6 months","timestamp":1637837542,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/592440987/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string s;\n        if (!root)\n            return s;\n        queue<TreeNode *> q;\n        q.push(root);\n        int i = 0;\n        while (!q.empty()) {\n            TreeNode *node = q.front();\n            if (node) {\n                //cout << node->val << endl;\n                s.push_back(node->val);\n            } else {\n                //cout << \"NULL \" << endl;\n                s.push_back('x');\n            }\n            q.pop();\n            //if (node->left == NULL && node->right == NULL)\n            //    continue;\n            if (node) {\n                if(node->left)\n                    q.push(node->left);\n                else\n                    q.push(NULL);\n                if(node->right)\n                    q.push(node->right);\n              else\n                    q.push(NULL);\n            }\n        }\n        //cout << s << endl;\n        return s;\n    }\n    TreeNode* InsertNode(TreeNode* root, char data)\n    {\n        queue<TreeNode*> q;\n        q.push(root);\n         while (!q.empty()) {\n            TreeNode* temp = q.front();\n            q.pop();\n             if (temp->left != NULL)\n                q.push(temp->left);\n            else {\n                if (data == 'x')\n                    temp->left = new TreeNode(1001);\n                else\n                    temp->left = new TreeNode(data);\n                return root;\n            }\n             if (temp->right != NULL)\n                q.push(temp->right);\n            else {\n                if (data == 'x')\n                    temp->right = new TreeNode(1001);\n                else\n                    temp->right = new TreeNode(data);\n                return root;\n            }\n        }\n        return root;\n    }\n    void inorder(TreeNode *root) {\n        if (!root)\n            return;\n        inorder(root->left);\n        if (root->left) {\n            if (root->left->val == 1001) {\n                delete root->left;\n                root->left = NULL;\n            }   \n        }\n        if (root->right) {\n            if (root->right->val == 1001) {\n                delete root->right;\n                root->right = NULL;\n            }   \n        }\n        inorder(root->right);\n    }\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if (data.size() == 0)\n            return NULL;\n        TreeNode* root = new TreeNode(data[0]);\n        //cout << data<<endl;\n        for (int i = 1; i < data.size(); ++i) {\n            //cout << data[i] << \" \";\n            root = InsertNode(root, data[i]);          \n        }\n        inorder(root);\n        return root;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));","compare_result":"1111111111001111111111111111111110000000000000000000","title_slug":"serialize-and-deserialize-binary-tree","has_notes":false}