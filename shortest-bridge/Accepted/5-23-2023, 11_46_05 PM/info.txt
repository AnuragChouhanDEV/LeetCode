{"id":955975564,"lang":"cpp","lang_name":"C++","time":"2 weeks, 2 days","timestamp":1684865765,"status":10,"status_display":"Accepted","runtime":"52 ms","url":"/submissions/detail/955975564/","is_pending":"Not Pending","title":"Shortest Bridge","memory":"18.3 MB","code":"class Solution {\npublic:\n    const int dx[4]={-1,1,0,0};\n    const int dy[4]={0,0,-1,1};\n    bool  bound(int i,int j,int r,int c) {\n          return (i<r && j<c && i>=0 && j>=0);\n    }\n    \n    void dfs(int i, int j, int R, int C, int set, vector<vector<int>>& grid) {\n        if (i < 0 || j < 0 || i >= R || j >= C || grid[i][j] != 1)\n            return;\n        grid[i][j] = set;\n        dfs(i+1, j, R, C, set, grid);\n        dfs(i-1, j, R, C, set, grid);\n        dfs(i, j+1, R, C, set, grid);\n        dfs(i, j-1, R, C, set, grid);\n    }\n    int shortestBridge(vector<vector<int>>& grid) {\n        // set one island to 2\n        int R = grid.size();\n        int C = grid[0].size();\n        int set = 2;\n        for (int i = 0; i < R; ++i) {\n            for (int j = 0; j < C;++j) {\n                if (grid[i][j] == 1) {\n                    dfs(i, j, R, C, set, grid);\n                    set = 3;\n                    break;\n                }\n            }\n            if (set == 3) break;\n        }\n        \n        int res = INT_MAX;\n        queue<pair<int,int>>q;\n        // start bfs from 2 to 1,\n        //get the new islands in queue\n        for(int i=0;i<R;++i) {\n            for(int j=0;j<C;++j) {\n                if(grid[i][j]==2) {\n                    q.push({i,j});       \n                }\n            }\n        }\n        int change=0;\n \n        //find the nearest distance to the 1 island from the island 2 \n        while(!q.empty()) {\n            ++change;\n            int sz=q.size();\n            while(sz--) {\n               auto node=q.front();\n               q.pop();\n                //4 directions\n               for(int x=0;x < 4;++x) {\n                    int new_i = node.first  + dx[x];\n                    int new_j = node.second + dy[x];\n \n                    if(bound(new_i,new_j,R,C) ) {\n                        if( grid[new_i][new_j]==0){\n                            grid[new_i][new_j]=2;\n                            q.push({new_i,new_j});\n                        }\n                        if(grid[new_i][new_j]==1)\n                            return change-1; \n                    }  \n                }     \n            }\n        }\n        return 0;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-bridge","has_notes":false}