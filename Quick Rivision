quick rivision

1. Two pointers: one input, opposite ends

Medium LeetCode problems using Two Pointers (opposite ends) technique start one pointer at index 0 (left) and another at the end of array/string (right), moving them inward based on conditions.

Core Medium Problems
Container With Most Water (11)
Two pointers at ends, move shorter height inward to maximize area between bars.
​

Valid Palindrome II (680)
Left=0, right=n-1, skip one mismatch and continue checking palindrome.
​

3Sum (15)
Fix one pointer, use two pointers (left, right) on remaining sorted array for target sum=0.
​

Trapping Rain Water (42)
Two pointers from opposite ends track left_max/right_max to calculate trapped water.
​

Two Sum II - Input Array Is Sorted (167)
Left=0, right=n-1, move based on sum vs target (smaller→right++, larger→left++).
​

Additional Medium Problems
LeetCode #	Problem Name	Pointer Movement Strategy
125	Valid Palindrome	Skip non-alphanumeric, compare inward
345	Reverse Vowels of a String	Skip non-vowels, swap vowels from ends
151	Reverse Words in a String	Find word boundaries from ends
76	Minimum Window Substring	Two pointers maintain valid window (expand/shrink from ends)
438	Find All Anagrams	Sliding window with opposite-end validation
Pattern Recognition Template
cpp
int left = 0, right = n-1;
while(left < right) {
    if(condition_to_move_left) left++;
    else if(condition_to_move_right) right--;
    else {
        // both valid, move both or return result
        left++; right--;
    }
}
Key Decision Rules:
​

Sum too small → move left++ (need larger value)

Sum too large → move right-- (need smaller value)

Shorter boundary → move that pointer inward

Valid solution found → move both inward

Practice these 8-10 problems to master opposite-ends two pointers completely.


2. Two pointers: two inputs, exhaust both

Medium LeetCode problems using Two Pointers (two inputs, exhaust both) technique use pointers on two separate arrays/inputs, advancing both based on comparison until both are exhausted.

Core Medium Problems
Median of Two Sorted Arrays (4)
Two pointers i on nums1, j on nums2. Partition both arrays to find median position.
​

Intersection of Two Arrays II (350)
i on nums1, j on nums2. When equal, add to result and advance both pointers.
​

Interval List Intersections (986)
i on firstList, j on secondList. Compare end times, advance pointer of earlier-ending interval.

Additional Medium Problems
LeetCode #	Problem Name	Two-Pointer Strategy
350	Intersection of Two Arrays II	Match equal values, advance both
986	Interval List Intersections	Compare interval ends, advance smaller
4	Median of Two Sorted Arrays	Partition both arrays simultaneously
253	Meeting Rooms II	Sort intervals, track active meetings
56	Merge Intervals	Merge overlapping from two sorted lists
Pattern Template
cpp
int i = 0, j = 0;  // i for first array, j for second
while(i < nums1.size() && j < nums2.size()) {
    if(nums1[i] < nums2[j]) {
        i++;  // advance first array only
    } else if(nums1[i] > nums2[j]) {
        j++;  // advance second array only
    } else {
        // equal case - advance BOTH
        result.push_back(nums1[i]);
        i++; j++;
    }
}
// Handle remaining elements if any
Key Decision Rules
Smaller value: Advance that array's pointer

Equal values: Process match, advance both pointers

Exhaust both arrays: Return result

One array exhausted: Process remaining from other array

Practice Priority: 4, 350, 986 - these capture 90% of the pattern.

This differs from "opposite ends" (single array, left→right) by using separate pointers for separate inputs.

3. Sliding window

Medium LeetCode problems using Sliding Window technique maintain a contiguous subarray/substring of variable or fixed size, expanding/shrinking based on conditions.

Fixed Size Window (Medium)
Longest Substring Without Repeating Characters (3)
Maintain window, shrink from left when duplicate found.
​

Maximum Average Subarray I (643)
Fixed size k, slide window computing sum/average.

Maximum Sum of Subarray of Size K
Fixed window size k, track max sum using prefix sum.

Variable Size Window (Medium)
LeetCode #	Problem Name	Window Logic
3	Longest Substring Without Repeating Characters	Shrink on duplicate chars
76	Minimum Window Substring	Expand until valid, shrink minimum
438	Find All Anagrams in a String	Fixed char count, slide & check
239	Sliding Window Maximum	Deque maintains max in window
567	Permutation in String	Fixed permutation length
Core Pattern Templates
Fixed Size Window
cpp
int windowSum = 0, result = INT_MIN;
for(int i = 0; i < k; i++) windowSum += arr[i];
result = windowSum;

for(int i = k; i < n; i++) {
    windowSum += arr[i] - arr[i-k];  // slide window
    result = max(result, windowSum);
}
Variable Size Window
cpp
int left = 0;
for(int right = 0; right < n; right++) {
    // add arr[right] to window
    while(windowInvalid(left, right)) {
        // remove arr[left] from window
        left++;
    }
    // update result [left..right]
}
Decision Tree
text
Is window size FIXED? → Use prefix sum / running total
    ↓ NO
Does window need MIN/MAX length? → Variable size (two pointers)
    ↓ NO  
Fixed character count? → Hashmap + slide
    ↓ NO
Max in each window? → Deque (239)
Must-Do Priority (5 problems)
3 - Longest substring (character frequency)

76 - Minimum window (covers all concepts)

438 - Anagrams (fixed pattern)

643 - Fixed size average

239 - Sliding window max (deque)

Master these 5 → 90% sliding window coverage. Variable size teaches expansion/contraction logic; fixed size teaches efficient sliding.

4. Build a prefix sum

Medium LeetCode problems using Prefix Sum technique precompute cumulative sums to answer range queries in O(1) time after O(n) preprocessing.

Core Medium Problems
Subarray Sum Equals K (560)
Hashmap tracks prefix sum frequencies. prefix[j] - prefix[i-1] == k finds valid subarrays.
​

Continuous Subarray Sum (523)
Check if any subarray sum divisible by k using prefix sums modulo k.

Find Pivot Index (724)
Prefix sums from left vs right to find balance point.

Key Medium Problems
LeetCode #	Problem Name	Prefix Sum Usage
560	Subarray Sum Equals K	Hashmap of prefix frequencies
523	Continuous Subarray Sum	Prefix % k collisions
238	Product of Array Except Self	Prefix/suffix products
152	Maximum Product Subarray	Prefix product tracking
53	Maximum Subarray	Kadane (prefix variant)
Prefix Sum Template
cpp
// 1. Build prefix array O(n)
vector<long> prefix(n+1, 0);
for(int i = 1; i <= n; i++) {
    prefix[i] = prefix[i-1] + arr[i-1];
}

// 2. Range sum query O(1)
int sum(int l, int r) {  // sum[0..r] - sum[0..l-1]
    return prefix[r+1] - prefix[l];
}
Advanced Hashmap Prefix (560 Pattern)
cpp
unordered_map<long, int> prefixCount;
prefixCount[0] = 1;  // empty prefix
long sum = 0, result = 0;

for(int num : nums) {
    sum += num;
    if(prefixCount.count(sum - k))
        result += prefixCount[sum - k];
    prefixCount[sum]++;
}
Decision Tree
text
Need range sums? → Basic prefix array
Count subarrays with sum K? → Hashmap prefix
Product except self? → Prefix + Suffix arrays  
Max subarray sum? → Kadane (running prefix)
Divisible by K? → Prefix % K
Must-Do Priority (4 problems)
560 - Hashmap prefix (hardest concept)

238 - Prefix/suffix products

523 - Modulo prefix

152 - Max product prefix

Master 560 → unlocks 80% prefix sum problems. Hashmap of prefix frequencies is the killer technique for subarray counting.

5. Efficient string building

Medium LeetCode problems requiring efficient string building use StringBuilder (Java) or StringBuffer/list + join (other languages) instead of string concatenation in loops to achieve O(n) time.

Core Problems Needing StringBuilder
Make The String Great (1544)
Stack + StringBuilder: Remove adjacent case-differing pairs, build result efficiently.
​
​

String Compression (443)
In-place chars array + count tracking, write compressed form directly (StringBuilder alternative).

Goal Parser Interpretation (1678)
Parse "G()", "(al)", build result string character by character.
​

Key Medium Problems
LeetCode #	Problem Name	Why StringBuilder Needed
1544	Make The String Great	Stack simulation removes pairs iteratively
443	String Compression	In-place write with counts
1047	Remove All Adjacent Duplicates	Stack removes identical adjacent chars
681	Next Closest Time	Generate 24 valid times, build strings
131	Palindrome Partitioning	Backtracking builds partition lists
Pattern: Stack + StringBuilder
java
public String makeGood(String s) {
    StringBuilder sb = new StringBuilder();
    for (char c : s.toCharArray()) {
        if (sb.length() > 0 && 
            Math.abs(sb.charAt(sb.length()-1) - c) == 32) {
            sb.deleteCharAt(sb.length()-1);  // pop
        } else {
            sb.append(c);  // push
        }
    }
    return sb.toString();
}
Python Equivalent (list + join)
python
def makeGood(s: str) -> str:
    stack = []
    for c in s:
        if stack and abs(ord(stack[-1]) - ord(c)) == 32:
            stack.pop()
        else:
            stack.append(c)
    return ''.join(stack)
When to Use Efficient Building
❌ Avoid (O(n²)):

java
String result = "";
for(char c : s) result += c;  // Quadratic!
✅ Use (O(n)):

java
StringBuilder sb = new StringBuilder();
for(char c : s) sb.append(c);
String result = sb.toString();
Must-Do Priority
1544 - Stack + StringBuilder core pattern

443 - In-place string mutation

1047 - Adjacent duplicate removal

1678 - Simple parsing to string

Key Insight: Any iterative string modification (palindrome cleanup, compression, parsing) needs StringBuilder to pass time limits on large inputs.

6. Linked list: fast and slow pointer

Medium LeetCode problems using Fast & Slow Pointers (Floyd's Tortoise and Hare) on linked lists detect cycles, find middles, and solve palindrome problems.

Core Medium Problems
Middle of the Linked List (876)
Slow moves 1 step, fast moves 2 steps. When fast reaches end, slow is at middle.

Linked List Cycle II (142)
Fast/slow detect cycle. Reset slow to head, move both 1 step to find cycle start.

Palindrome Linked List (234)
Fast reaches end, slow at middle. Reverse second half, compare with first half.

Key Medium Problems
LeetCode #	Problem Name	Fast/Slow Usage
876	Middle of the Linked List	Find middle in one pass
142	Linked List Cycle II	Detect cycle + find entry point
234	Palindrome Linked List	Reverse second half for comparison
287	Find the Duplicate Number	Cycle detection in array
202	Happy Number	Cycle detection via sum of squares
Core Pattern Template
cpp
ListNode* slow = head, *fast = head;
while(fast && fast->next) {
    slow = slow->next;        // 1 step
    fast = fast->next->next;  // 2 steps
    // Check condition (middle, cycle, etc.)
}
Problem-Specific Variations
1. Middle (876)
cpp
while(fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
}
return slow;  // middle node
2. Cycle Detection + Entry (142)
cpp
// Phase 1: Detect cycle
while(fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
    if(slow == fast) break;  // cycle found
}

// Phase 2: Find entry
slow = head;
while(slow != fast) {
    slow = slow->next;
    fast = fast->next;
}
return slow;  // cycle start
3. Palindrome (234)
cpp
// Find middle
while(fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
}
// Reverse second half from slow, compare
Why It Works (Math)
Middle Detection: Fast travels 2n, slow travels n. When fast finishes, slow is at n/2.

Cycle Entry: Distance from head to cycle + cycle length = meeting point distance.

Must-Do Priority (3 problems)
876 - Basic middle finding

142 - Complete cycle detection

234 - Real-world application (palindrome)

Master these 3 → 85% fast/slow coverage. The cycle detection math (Phase 2 reset) is the key insight.
