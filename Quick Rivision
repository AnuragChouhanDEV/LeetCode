quick rivision

1. Two pointers: one input, opposite ends

Medium LeetCode problems using Two Pointers (opposite ends) technique start one pointer at index 0 (left) and another at the end of array/string (right), moving them inward based on conditions.

Core Medium Problems
Container With Most Water (11)
Two pointers at ends, move shorter height inward to maximize area between bars.
​

Valid Palindrome II (680)
Left=0, right=n-1, skip one mismatch and continue checking palindrome.
​

3Sum (15)
Fix one pointer, use two pointers (left, right) on remaining sorted array for target sum=0.
​

Trapping Rain Water (42)
Two pointers from opposite ends track left_max/right_max to calculate trapped water.
​

Two Sum II - Input Array Is Sorted (167)
Left=0, right=n-1, move based on sum vs target (smaller→right++, larger→left++).
​

Additional Medium Problems
LeetCode #	Problem Name	Pointer Movement Strategy
125	Valid Palindrome	Skip non-alphanumeric, compare inward
345	Reverse Vowels of a String	Skip non-vowels, swap vowels from ends
151	Reverse Words in a String	Find word boundaries from ends
76	Minimum Window Substring	Two pointers maintain valid window (expand/shrink from ends)
438	Find All Anagrams	Sliding window with opposite-end validation
Pattern Recognition Template
cpp
int left = 0, right = n-1;
while(left < right) {
    if(condition_to_move_left) left++;
    else if(condition_to_move_right) right--;
    else {
        // both valid, move both or return result
        left++; right--;
    }
}
Key Decision Rules:
​

Sum too small → move left++ (need larger value)

Sum too large → move right-- (need smaller value)

Shorter boundary → move that pointer inward

Valid solution found → move both inward

Practice these 8-10 problems to master opposite-ends two pointers completely.


2. Two pointers: two inputs, exhaust both

Medium LeetCode problems using Two Pointers (two inputs, exhaust both) technique use pointers on two separate arrays/inputs, advancing both based on comparison until both are exhausted.

Core Medium Problems
Median of Two Sorted Arrays (4)
Two pointers i on nums1, j on nums2. Partition both arrays to find median position.
​

Intersection of Two Arrays II (350)
i on nums1, j on nums2. When equal, add to result and advance both pointers.
​

Interval List Intersections (986)
i on firstList, j on secondList. Compare end times, advance pointer of earlier-ending interval.

Additional Medium Problems
LeetCode #	Problem Name	Two-Pointer Strategy
350	Intersection of Two Arrays II	Match equal values, advance both
986	Interval List Intersections	Compare interval ends, advance smaller
4	Median of Two Sorted Arrays	Partition both arrays simultaneously
253	Meeting Rooms II	Sort intervals, track active meetings
56	Merge Intervals	Merge overlapping from two sorted lists
Pattern Template
cpp
int i = 0, j = 0;  // i for first array, j for second
while(i < nums1.size() && j < nums2.size()) {
    if(nums1[i] < nums2[j]) {
        i++;  // advance first array only
    } else if(nums1[i] > nums2[j]) {
        j++;  // advance second array only
    } else {
        // equal case - advance BOTH
        result.push_back(nums1[i]);
        i++; j++;
    }
}
// Handle remaining elements if any
Key Decision Rules
Smaller value: Advance that array's pointer

Equal values: Process match, advance both pointers

Exhaust both arrays: Return result

One array exhausted: Process remaining from other array

Practice Priority: 4, 350, 986 - these capture 90% of the pattern.

This differs from "opposite ends" (single array, left→right) by using separate pointers for separate inputs.

3. Sliding window

Medium LeetCode problems using Sliding Window technique maintain a contiguous subarray/substring of variable or fixed size, expanding/shrinking based on conditions.

Fixed Size Window (Medium)
Longest Substring Without Repeating Characters (3)
Maintain window, shrink from left when duplicate found.
​

Maximum Average Subarray I (643)
Fixed size k, slide window computing sum/average.

Maximum Sum of Subarray of Size K
Fixed window size k, track max sum using prefix sum.

Variable Size Window (Medium)
LeetCode #	Problem Name	Window Logic
3	Longest Substring Without Repeating Characters	Shrink on duplicate chars
76	Minimum Window Substring	Expand until valid, shrink minimum
438	Find All Anagrams in a String	Fixed char count, slide & check
239	Sliding Window Maximum	Deque maintains max in window
567	Permutation in String	Fixed permutation length
Core Pattern Templates
Fixed Size Window
cpp
int windowSum = 0, result = INT_MIN;
for(int i = 0; i < k; i++) windowSum += arr[i];
result = windowSum;

for(int i = k; i < n; i++) {
    windowSum += arr[i] - arr[i-k];  // slide window
    result = max(result, windowSum);
}
Variable Size Window
cpp
int left = 0;
for(int right = 0; right < n; right++) {
    // add arr[right] to window
    while(windowInvalid(left, right)) {
        // remove arr[left] from window
        left++;
    }
    // update result [left..right]
}
Decision Tree
text
Is window size FIXED? → Use prefix sum / running total
    ↓ NO
Does window need MIN/MAX length? → Variable size (two pointers)
    ↓ NO  
Fixed character count? → Hashmap + slide
    ↓ NO
Max in each window? → Deque (239)
Must-Do Priority (5 problems)
3 - Longest substring (character frequency)

76 - Minimum window (covers all concepts)

438 - Anagrams (fixed pattern)

643 - Fixed size average

239 - Sliding window max (deque)

Master these 5 → 90% sliding window coverage. Variable size teaches expansion/contraction logic; fixed size teaches efficient sliding.

4. Build a prefix sum

Medium LeetCode problems using Prefix Sum technique precompute cumulative sums to answer range queries in O(1) time after O(n) preprocessing.

Core Medium Problems
Subarray Sum Equals K (560)
Hashmap tracks prefix sum frequencies. prefix[j] - prefix[i-1] == k finds valid subarrays.
​

Continuous Subarray Sum (523)
Check if any subarray sum divisible by k using prefix sums modulo k.

Find Pivot Index (724)
Prefix sums from left vs right to find balance point.

Key Medium Problems
LeetCode #	Problem Name	Prefix Sum Usage
560	Subarray Sum Equals K	Hashmap of prefix frequencies
523	Continuous Subarray Sum	Prefix % k collisions
238	Product of Array Except Self	Prefix/suffix products
152	Maximum Product Subarray	Prefix product tracking
53	Maximum Subarray	Kadane (prefix variant)
Prefix Sum Template
cpp
// 1. Build prefix array O(n)
vector<long> prefix(n+1, 0);
for(int i = 1; i <= n; i++) {
    prefix[i] = prefix[i-1] + arr[i-1];
}

// 2. Range sum query O(1)
int sum(int l, int r) {  // sum[0..r] - sum[0..l-1]
    return prefix[r+1] - prefix[l];
}
Advanced Hashmap Prefix (560 Pattern)
cpp
unordered_map<long, int> prefixCount;
prefixCount[0] = 1;  // empty prefix
long sum = 0, result = 0;

for(int num : nums) {
    sum += num;
    if(prefixCount.count(sum - k))
        result += prefixCount[sum - k];
    prefixCount[sum]++;
}
Decision Tree
text
Need range sums? → Basic prefix array
Count subarrays with sum K? → Hashmap prefix
Product except self? → Prefix + Suffix arrays  
Max subarray sum? → Kadane (running prefix)
Divisible by K? → Prefix % K
Must-Do Priority (4 problems)
560 - Hashmap prefix (hardest concept)

238 - Prefix/suffix products

523 - Modulo prefix

152 - Max product prefix

Master 560 → unlocks 80% prefix sum problems. Hashmap of prefix frequencies is the killer technique for subarray counting.
