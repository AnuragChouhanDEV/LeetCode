{"id":948521367,"lang":"cpp","lang_name":"C++","time":"4Â weeks","timestamp":1683821861,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/948521367/","is_pending":"Not Pending","title":"Merge k Sorted Lists","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *reverse(ListNode *head) {\n        if (!head)\n            return head;\n        ListNode *curr = head;\n        ListNode *prev = NULL;\n        ListNode *next;\n        while (curr) {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if (lists.size() == 0)\n            return NULL;\n        auto cmp = [](ListNode*a,ListNode*b){return a->val > b->val;};\n        priority_queue<ListNode*, vector<ListNode*>,decltype(cmp)> pq(cmp);\n        for (auto it:lists)\n            if (it) pq.push(it);\n        ListNode* head = pq.top();\n        pq.pop();\n        if (head->next)\n            pq.push(head->next);\n        ListNode *curr = head;\n        while (!pq.empty()) {\n            ListNode *tmp = pq.top();\n            pq.pop();\n            curr->next = tmp;\n            curr = tmp;\n            if (tmp->next)\n                pq.push(tmp->next);\n        }\n        return head;\n    }\n};","compare_result":"1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-k-sorted-lists","has_notes":false}