{"id":710474811,"lang":"cpp","lang_name":"C++","time":"1Â year","timestamp":1653915843,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/710474811/","is_pending":"Not Pending","title":"LFU Cache","memory":"N/A","code":"class LFUCache {\npublic:\n    class Node {\n\t\tpublic:\n\t\tpair<int,int> kv;\n\t\tNode *prev;\n\t\tNode *next;\n\t\tNode (int key, int value) {\n\t\t\tkv.first = key;\n\t\t\tkv.second = value;\n\t\t\tprev = NULL;\n\t\t\tnext = NULL;\n\t\t}\n\t};\n    int cap;\n\tmap<int, Node*> ma;\n\tNode *head;\n\tNode *tail;\n    LFUCache(int capacity) {\n        cap = capacity;\n        head = NULL;\n        tail = NULL;\n    }\n    void add_node(Node *new_node) {\n\t\t//cout << \"add_node ENTER\" << endl;\n\t\tif (head == NULL || tail == NULL) {\n\t\t\thead = tail = new_node;\n\t\t} else {\n\t\t\tnew_node->next = head;\n\t\t\thead->prev = new_node;\n\t\t\thead = new_node;\n\t\t}\n\t\t//cout << \"add_node EXIT\" << endl;\n\t}\n\t\n\tvoid del_node(Node *del) {\n\t\t//cout << \"del_node ENTER \" << endl;\n\t\tif (del == head) {\n\t\t\thead = head->next;\n\t\t\tif (head && head->prev)\n\t\t\t\thead->prev = NULL;\n\t\t\tdelete del;\n\t\t\t//cout << \"del_node EXIT 1\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (del == tail) {\n\t\t\ttail = tail->prev;\n\t\t\tif (tail && tail->next)\n\t\t\t\ttail->next = NULL;\n\t\t\tdelete del;\n\t\t\t//cout << \"del_node EXIT 2\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tdel->next->prev = del->prev;\n\t\tdel->prev->next = del->next;\n\t\tdelete del;\n\t\t//cout << \"del_node EXIT 3\" << endl;\n\t}\n    int get(int key) {\n\t\tif (ma.find(key) != ma.end()) {\n\t\t\tNode *tmp = ma[key];\n\t\t\tint val = tmp->kv.second;\n\t\t\tdel_node(tmp);\n\t\t\tma.erase(key);\n\t\t\ttmp = new Node({key, val});\n\t\t\tadd_node(tmp);\n\t\t\tma[key] = tmp;\n\t\t\t//cout << \"get EXIT \" << endl;\n\t\t\treturn tmp->kv.second;\n\t\t}\n\t\t//cout << \"get EXIT null \" << endl;\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if (ma.find(key) != ma.end()) {\n\t\t\tNode *tmp = ma[key];\n\t\t\tdel_node(tmp);\n\t\t\tma.erase(key);\n\t\t\ttmp = new Node({key, value});\n\t\t\tadd_node(tmp);\n\t\t\tma[key] = tmp;\n\t\t} else if (ma.size() == cap) {\n\t\t\tma.erase(tail->kv.first);\n\t\t\tdel_node(tail);\n\t\t\tNode *tmp = new Node({key, value});\n\t\t\tadd_node(tmp);\n\t\t\tma[key]=tmp;\n\t\t} else {\n\t\t\tNode *tmp = new Node({key, value});\n\t\t\tadd_node(tmp);\n\t\t\tma[key]=tmp;\n\t\t}\n    }\n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"10110000000000000000000000","title_slug":"lfu-cache","has_notes":false}