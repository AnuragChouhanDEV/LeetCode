{"id":346702972,"lang":"cpp","lang_name":"C++","time":"3Â years","timestamp":1590853368,"status":10,"status_display":"Accepted","runtime":"556 ms","url":"/submissions/detail/346702972/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"64.6 MB","code":"class Solution {\n    bool is_bipartite(vector<vector<int>>& adj, int N, int node, vector<int>& color) {\n        queue<int> q;\n        q.push(node);\n        color[node] = 1;\n        \n        while(!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (int el:adj[curr]) {\n                if (color[el] == color[curr]) {\n                    return false;\n                }\n                if (color[el] == -1) {\n                    color[el] = 1 - color[curr];\n                    q.push(el);\n                }\n            }\n        }\n        return true;\n    }\npublic:\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        int len = dislikes.size();\n        vector<vector<int>> adj(N+1);\n        for (int i = 0; i < len; ++i) {\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\n        }\n        vector<int> color(N+1, -1);\n        for (int i=0;i<N;++i){\n            if (color[i] == -1) {\n                if (!is_bipartite(adj,N,i,color)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false}